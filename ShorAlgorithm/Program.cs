using System.Numerics;
using System.Security.Cryptography;

namespace ShorAlgorithm;

class Program
{
    /*********************************************************************
     *	shor.cc -- Use Shor's Algorithm
     *		to factor a large BigInteger
     * ChangeLog:
     *  970225 -- Created by Paul Herman <a540pau@pslc.ucla.edu>
    **********************************************************************/
    static BigInteger GenerateRandomBigInteger(int count = 8)
    {
        // 创建一个RandomNumberGenerator实例
        using var rng = RandomNumberGenerator.Create();
        // 生成一个足够长的字节数组，例如16字节（128位）
        var randomBytes = new byte[count]; // 可以根据需要增加字节数以生成更大的数
        rng.GetBytes(randomBytes);

        // 将字节数组转换为BigInteger
        // 注意：这里使用了BigEndianBitConverter，因为BigInteger期望高位在前（大端格式）
        return new BigInteger(randomBytes);
    }

    /********************************************************************
    /*  Period:  This computes the size of the group generated by a mod n
    /*           i.e. |<a>|
    /********************************************************************/
    static int GetCycle(BigInteger a, BigInteger n)
    {
        var count = 0L;

        Parallel.For(1L, long.MaxValue, (i, state) =>
        {
            if (BigInteger.ModPow(a, i, n) == BigInteger.One)
            {
                count = i;
                state.Stop();
            }
        });

        return (int)count;
    }

    /*********************
    /*  ShorFactor:  Finds a factor of n by looking at the group generated
    /*               by <a> mod n.  Let t = |<a>|/2  .  Check to see if
    /*               t +/- 1 and n have a common factor.  If not, try another a
    /*********************/

    static BigInteger ShorFactor(BigInteger n, BigInteger a, long retries = 4096, bool use_cycle = false)
    {
        BigInteger t1, t2, f1, f2;
        int r, j;
        
        a = a.IsZero ? GenerateRandomBigInteger(n.GetByteCount()) : a;

        while (true)
        {
        retry:
            j = 2;
            //我在这里改为随机化
            a = GenerateRandomBigInteger(n.GetByteCount());

            r = use_cycle ? GetCycle(a, n) : (int)BigInteger.ModPow(a, j, n);
            for (; ; j++)
            {
                //随机数a是n的因子
                f1 = BigInteger.GreatestCommonDivisor(a, n);
                if (f1 == n) goto retry;
                if (f1 != BigInteger.One)
                {
                    Console.WriteLine($"First Found f1 = {f1}");
                    return f1;
                }
                //t1和t2分别是a^((a^j mod n)/2) mod n的+1和-1
                t1 = BigInteger.ModPow(a, (r >> 1), n);
                t1 += 1;
                t2 = t1 - 2;

                //t1=(a^(r/2) mod n) + 1
                //t2=(a^(r/2) mod n) - 1

                //测试t1
                f1 = BigInteger.GreatestCommonDivisor(t1, n);
                if (f1 != BigInteger.One && f1 != n)
                    return f1;
                //测试t2
                f2 = BigInteger.GreatestCommonDivisor(t2, n);
                if (f2 != BigInteger.One && f2 != n)
                    return f2;
                //如果t1和t2都没有找到因子，那么就换一个a继续试s
                a += 1;
                if (--retries == 0)
                    return n;
                //计算a^j mod n,求r的下一个数值
                r = (int)BigInteger.ModPow(a, j, n);
                //如果r为负数，说明a^j mod n的结果是负数，这不应该发生，因为模运算的结果应该在0到n-1之间
                if (r < 0)
                {
                    goto retry;
                }
            }
        }
    }

    const long default_value = 70191551;
    static int Main(string[] args)
    {
        var n = args.Length > 0
            ? BigInteger.TryParse(args[0], out var v)
            ? v : default_value
            : default_value
            ;
        Console.WriteLine($"Factoring n = {n}:");
        var i = 1;
        while (n != BigInteger.One)
        {
            var k = ShorFactor(n,BigInteger.Zero);
            Console.WriteLine($"Found q{i} is = {k}");
            n /= k;
            i++;
        }
        Console.WriteLine("Factorization complete.");

        return 0;
    }
}
